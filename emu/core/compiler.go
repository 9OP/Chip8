package core

import (
	"fmt"
)

// type Opcode struct {
// 	inst Instruction
// 	name string
// }

// compiler: txt -> binary
// mapper token -> 0x...

// decompiler: binary -> txt
// mapper 0x... -> token

func opcodeGenerator(rom []uint8) <-chan uint16 {
	ch := make(chan uint16)
	go func() {
		defer close(ch)
		pc := 0
		for pc < len(rom) {
			upper_byte := rom[pc]
			lower_byte := rom[pc+1]
			pc += 2
			var opcode uint16 = uint16(upper_byte)<<8 | uint16(lower_byte)
			ch <- opcode
		}
	}()
	return ch
}

type Opcode struct {
	name string
	args []string
}

// Type of args: V is register, "" is byte, I is i register
var _a = []string{""}
var _x = []string{"V"}
var _i_b = []string{"I", ""}
var _i_x = []string{"I", "V"}
var _x_b = []string{"V", ""}
var _x_y = []string{"V", "V"}
var _x_y_b = []string{"V", "V", ""}

var OPCODES = map[uint16]Opcode{
	0x0000: {name: "NOP"},
	0x00E0: {name: "CLS"},
	0x00EE: {name: "RET"},
	0x1000: {name: "JMP", args: _a},
	0x2000: {name: "CALL", args: _a},
	0x3000: {name: "SE", args: _x_b},
	0x4000: {name: "SNE", args: _x_b},
	0x5000: {name: "SE", args: _x_y},
	0x6000: {name: "LD", args: _x_b},
	0x7000: {name: "ADD", args: _x_b},
	0x8000: {name: "LD", args: _x_y},
	0x8001: {name: "OR", args: _x_y},
	0x8002: {name: "AND", args: _x_y},
	0x8003: {name: "XOR", args: _x_y},
	0x8004: {name: "ADD", args: _x_y},
	0x8005: {name: "SUB", args: _x_y},
	0x8006: {name: "SHR", args: _x},
	0x8007: {name: "SUBN", args: _x_y},
	0x800E: {name: "SHL", args: _x},
	0x9000: {name: "SNE", args: _x_y},
	0xA000: {name: "LD", args: _i_b},
	0xB000: {name: "JMP0", args: _a},
	0xC000: {name: "RND", args: _x_b},
	0xD000: {name: "DRAW", args: _x_y_b},
	0xE09E: {name: "SKP", args: _x},
	0xE0A1: {name: "SKNP", args: _x},
	0xF007: {name: "LD_DTN", args: _x},
	0xF00A: {name: "WAIT_K", args: _x},
	0xF015: {name: "LD_DT", args: _x},
	0xF018: {name: "LD_ST", args: _x},
	0xF01E: {name: "ADD", args: _i_x},
	0xF029: {name: "LD_F", args: _i_x},
	0xF033: {name: "LD_BCD", args: _x},
	0xF055: {name: "LD_RAM", args: _x},
	0xF065: {name: "LD_REG", args: _x},
}

func decodeOpcode(opcode uint16) (Opcode, bool) {
	// 0xABCD -> 0xA, 0xB, 0xC, 0xD
	digit1 := uint8((opcode >> 12) & 0xF)

	switch digit1 {
	case 0x0:
		op, ok := OPCODES[opcode]
		return op, ok

	case 0x1, 0x2, 0x3, 0x4, 0x6, 0x7, 0xA, 0xB, 0xC, 0xD:
		op, ok := OPCODES[opcode&0xF000]
		return op, ok

	case 0x5, 0x8, 0x9:
		op, ok := OPCODES[opcode&0xF00F]
		return op, ok

	case 0xE, 0xF:
		op, ok := OPCODES[opcode&0xF0FF]
		return op, ok

	default:
		return Opcode{}, false
	}
}

func Decompile(rom []uint8) ([]string, error) {
	res := []string{}
	for opcode := range opcodeGenerator(rom) {
		op, ok := decodeOpcode(opcode)
		// opcode_name := getOpcodeName(opcode)
		// opcode_args
		fmt.Printf("%v %v %x\n", op.name, ok, opcode)
	}

	return res, nil
}

// Blitz
var ROM = []uint8{
	0x12, 0x17, 0x42, 0x4c, 0x49, 0x54, 0x5a, 0x20, 0x42, 0x79, 0x20, 0x44, 0x61, 0x76, 0x69, 0x64,
	0x20, 0x57, 0x49, 0x4e, 0x54, 0x45, 0x52, 0xa3, 0x41, 0x60, 0x4, 0x61, 0x9, 0x62, 0xe, 0x67,
	0x4, 0xd0, 0x1e, 0xf2, 0x1e, 0x70, 0xc, 0x30, 0x40, 0x12, 0x21, 0xf0, 0xa, 0x0, 0xe0, 0x22,
	0xd9, 0xf0, 0xa, 0x0, 0xe0, 0x8e, 0x70, 0xa3, 0x1e, 0x6b, 0x1f, 0xcc, 0x1f, 0x8c, 0xc4, 0xdc,
	0xb2, 0x3f, 0x1, 0x12, 0x49, 0xdc, 0xb2, 0x12, 0x39, 0xca, 0x7, 0x7a, 0x1, 0x7b, 0xfe, 0xdc,
	0xb2, 0x7a, 0xff, 0x3a, 0x0, 0x12, 0x4d, 0x7e, 0xff, 0x3e, 0x0, 0x12, 0x39, 0x6b, 0x0, 0x8c,
	0x70, 0x6d, 0x0, 0x6e, 0x0, 0xa3, 0x1b, 0xdd, 0xe3, 0x3f, 0x0, 0x12, 0xc1, 0x3b, 0x0, 0x12,
	0x81, 0x60, 0x5, 0xe0, 0x9e, 0x12, 0x87, 0x6b, 0x1, 0x88, 0xd0, 0x78, 0x2, 0x89, 0xe0, 0x79,
	0x3, 0xa3, 0x1e, 0xd8, 0x91, 0x81, 0xf0, 0x60, 0x5, 0xf0, 0x15, 0xf0, 0x7, 0x30, 0x0, 0x12,
	0x8b, 0x3b, 0x1, 0x12, 0xab, 0xa3, 0x1e, 0x31, 0x1, 0xd8, 0x91, 0x79, 0x1, 0x39, 0x20, 0x12,
	0xab, 0x6b, 0x0, 0x31, 0x0, 0x7c, 0xff, 0x4c, 0x0, 0x12, 0xbb, 0xa3, 0x1b, 0xdd, 0xe3, 0x7d,
	0x2, 0x3d, 0x40, 0x12, 0xb9, 0x6d, 0x0, 0x7e, 0x1, 0x12, 0x65, 0x0, 0xe0, 0x77, 0x2, 0x12,
	0x2d, 0xa3, 0x1b, 0xdd, 0xe3, 0x60, 0x14, 0x61, 0x2, 0x62, 0xb, 0xa3, 0x20, 0xd0, 0x1b, 0xf2,
	0x1e, 0x70, 0x8, 0x30, 0x2c, 0x12, 0xcd, 0x12, 0xd7, 0x60, 0xa, 0x61, 0xd, 0x62, 0x5, 0xa3,
	0x7, 0xd0, 0x15, 0xf2, 0x1e, 0x70, 0x8, 0x30, 0x2a, 0x12, 0xe1, 0x80, 0x70, 0x70, 0xfe, 0x80,
	0x6, 0xa3, 0x87, 0xf0, 0x33, 0xf2, 0x65, 0x60, 0x2d, 0xf1, 0x29, 0x61, 0xd, 0xd0, 0x15, 0x70,
	0x5, 0xf2, 0x29, 0xd0, 0x15, 0x0, 0xee, 0x83, 0x82, 0x83, 0x82, 0xfb, 0xe8, 0x8, 0x88, 0x5,
	0xe2, 0xbe, 0xa0, 0xb8, 0x20, 0x3e, 0x80, 0x80, 0x80, 0x80, 0xf8, 0x80, 0xf8, 0xfc, 0xc0, 0xc0,
	0xf9, 0x81, 0xdb, 0xcb, 0xfb, 0x0, 0xfa, 0x8a, 0x9a, 0x99, 0xf8, 0xef, 0x2a, 0xe8, 0x29, 0x29,
	0x0, 0x6f, 0x68, 0x2e, 0x4c, 0x8f, 0xbe, 0xa0, 0xb8, 0xb0, 0xbe, 0x0, 0xbe, 0x22, 0x3e, 0x34,
	0xb2, 0xd8, 0xd8, 0x0, 0xc3, 0xc3, 0x0, 0xd8, 0xd8, 0x0, 0xc3, 0xc3, 0x0, 0xd8, 0xd8, 0xc0,
	0xc0, 0x0, 0xc0, 0xc0, 0x0, 0xc0, 0xc0, 0x0, 0xc0, 0xc0, 0x0, 0xdb, 0xdb, 0xdb, 0xdb, 0x0,
	0x18, 0x18, 0x0, 0x18, 0x18, 0x0, 0x18, 0x18, 0x0, 0xdb, 0xdb, 0xdb, 0xdb, 0x0, 0x18, 0x18,
	0x0, 0x18, 0x18, 0x0, 0x18, 0x18, 0x0, 0x18, 0x18, 0xdb, 0xdb, 0x0, 0x3, 0x3, 0x0, 0x18,
	0x18, 0x0, 0xc0, 0xc0, 0x0, 0xdb, 0xdb,
}

func Test() {
	res, err := Decompile(ROM)
	fmt.Println(res, err)
}
